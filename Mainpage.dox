/** \file Mainpage.dox
    \brief Mainpage of the %Phonon API Documentation.
*/
/** \mainpage The Phonon API.

\section phonon_intro Introduction
%Phonon is the Multimedia API for %KDE. You should evaluate whether %Phonon
supplies all you need before looking at frameworks like GStreamer, NMM or Helix.
The range of applications goes from full featured media players and capture
applications to voice/video chats.

\section phonon_overview A Basic Overview
In %Phonon there are two main concepts: MediaProducers and Outputs. They can be
connected using Path objects which also allow the insertion of Effect objects
between producer and output.

\section phonon_tutorial Tutorial
\ref phonon_tut1 "a simple audio player"
\ref phonon_tut2 "add a playlist"
\ref phonon_tut3 "crossfades"
\ref phonon_tut4 "show videos"

\section phonon_frontend The Frontend API
 - for simple playback use \ref Phonon::SimplePlayer
 - add ref to overview of frontend objects
 - \ref Phonon "The Phonon namespace"
 - \ref Phonon::MediaObject "The central class for playback functionality (MediaObject)"

\section phonon_backend_development Backend Development
If you want to write a new backend for %Phonon this is for you:
 - \ref phonon_backend_development_page "Phonon Backend Development"














\page phonon_tut1 Phonon Tutorial Part 1: a simple audio player
\code
class Player : public QObject
{
  Q_OBJECT
  public:
    Player( QObject* parent );
    void play( const KUrl& url );

  private:
    Phonon::MediaObject* m_media;
    Phonon::AudioPath*   m_audioPath;
    Phonon::AudioOutput* m_audioOutput;
};

Player::Player( QObject* parent )
  : QObject( parent )
  , m_media( new Phonon::MediaObject( this ) )
  , m_audioPath( new Phonon::AudioPath( this ) )
  , m_audioOutput( new Phonon::AudioOutput( this ) )
{
  m_audioOutput->setCategory( Phonon::MusicCategory );
  m_media->addAudioPath( m_audioPath );
  m_audioPath->addOutput( m_audioOutput );
}

void Player::play( const KUrl& url )
{
  m_media->setUrl( url );
  m_media->play();
}
\endcode








\page phonon_backend_development_page Phonon Backend Development
The backend is the most important part in %Phonon to provide functionality. This
document will get you started how backends work, how to start development of a
new backend and how to understand existing backend code.

\section phonon_backend_introduction Introduction

The first step is to understand how the %Phonon frontend calls the backend: In
the frontend objects all backend objects are "only" QObjects. But QObject has
powerful introspection capabilities that %Phonon uses to call methods in the
backend. If you're interested look at \ref QMetaObject::invokeMethod. In order
to make sure that a backend is fully operational (there are no abstract classes
that tell the backend developer what method signatures are wrong or what
methods are missing) there are two test programs compiled with kdelibs (if
KDE4_BUILD_TESTS is set in cmake) that inspects the backend.

In short that requires the backend classes to inherit from QObject and to make
all methods that are to be called from the frontend slots or prefixed with
Q_INVOKABLE (the latter doesn't work reliable with Qt 4.1.3 at least, so you
should simply make those methods slots).

\section phonon_backend_classes The Backend Classes

The central class that needs to be implemented is the backend factory class,
throughout this documentation simply called Backend:
\ref phonon_Backend "Backend"








\page phonon_Backend The Backend Class

\section phonon_Backend_requiredfunctions Required Functions
\li const char* \ref phonon_Backend_uiLibrary "uiLibrary()"
\li \ref QSet "QSet<int>" \ref phonon_Backend_audioCaptureDeviceIndexes "audioCaptureDeviceIndexes()"
\li QString \ref phonon_Backend_audioCaptureDeviceName "audioCaptureDeviceName( int )"
\li QString \ref phonon_Backend_audioCaptureDeviceDescription "audioCaptureDeviceDescription( int )"
\li qint32 \ref phonon_Backend_audioCaptureDeviceVideoIndex "audioCaptureDeviceVideoIndex( int )"

\section phonon_Backend_optionalfunctions Optional Functions
\li const char* \ref phonon_Backend_uiSymbol "uiSymbol()"
\li QObject* \ref phonon_Backend_createAudioDataOutput "createAudioDataOutput( QObject* )"
\li QObject* \ref phonon_Backend_createAudioEffect "createAudioEffect( int, QObject* )"
\li QObject* \ref phonon_Backend_createAudioOutput "createAudioOutput( QObject* )"
\li QObject* \ref phonon_Backend_createAudioPath "createAudioPath( QObject* )"
\li QObject* \ref phonon_Backend_createAvCapture "createAvCapture( QObject* )"
\li QObject* \ref phonon_Backend_createBrightnessControl "createBrightnessControl( QObject* )"
\li QObject* \ref phonon_Backend_createByteStream "createByteStream( QObject* )"
\li QObject* \ref phonon_Backend_createMediaObject "createMediaObject( QObject* )"
\li QObject* \ref phonon_Backend_createMediaQueue "createMediaQueue( QObject* )"
\li QObject* \ref phonon_Backend_createVideoDataOutput "createVideoDataOutput( QObject* )"
\li QObject* \ref phonon_Backend_createVideoEffect "createVideoEffect( int, QObject* )"
\li QObject* \ref phonon_Backend_createVideoPath "createVideoPath( QObject* )"
\li QObject* \ref phonon_Backend_createVisualization "createVisualization( QObject* )"
\li QObject* \ref phonon_Backend_createVolumeFaderEffect "createVolumeFaderEffect( QObject* )"

\section Member Function Documentation
\subsection phonon_Backend_uiLibrary const char* uiLibrary()
\returns The name of the library that needs to be loaded to get access to the
GUI dependent classes.
\see \ref phonon_UiBackend

\subsection phonon_Backend_uiSymbol const char* uiSymbol()
This method is useful if you want to put the GUI dependent and GUI indepentend
classes into the same DSO. Then \ref phonon_Backend_uiLibrary "uiLibrary()"
returns the same library as is specified in the .desktop file.
\returns The symbol in the library that needs to be called to get access to the
\ref phonon_UiBackend "UiBackend" instance.

\subsection phonon_Backend_audioCaptureDeviceIndexes QSet<int> audioCaptureDeviceIndexes()
\returns A set of indexes that identify the audio capture devices the backend
supports. This list needs to be compiled from looking at available hardware
devices and "virtual devices". The implementation should use cached information,
but you need to invalidate the cache whenever the hardware configuration changes
or new virtual devices come available.

\subsection phonon_Backend_audioCaptureDeviceName QString audioCaptureDeviceName( int index )
\param index The index of the device. This is one of the indexes the backend
returned via \ref phonon_Backend_audioCaptureDeviceIndexes
\returns A translated user visible string to name the device.

\subsection phonon_Backend_audioCaptureDeviceDescription QString audioCaptureDeviceDescription( int index )
\param index The index of the device. This is one of the indexes the backend
returned via \ref phonon_Backend_audioCaptureDeviceIndexes
\returns A translated user visible string to describe the device.

\subsection phonon_Backend_audioCaptureDeviceVideoIndex qint32 audioCaptureDeviceVideoIndex( int index )
\param index The index of the device. This is one of the indexes the backend
returned via \ref phonon_Backend_audioCaptureDeviceIndexes
\returns An index of a video capture device that is associated with the given
audio capture device. For example a webcam might have both a video and an audio
capture device, and in order give the user a hint that the audio and video
capture devices belong together this index is used.

\returns If there is no associated
video capture device return -1.

*/
// DOXYGEN_REFERENCES = kdecore kio phonon/ui
// DOXYGEN_SET_EXPAND_AS_DEFINED = PHONON_ABSTRACTBASE PHONON_OBJECT PHONON_HEIR
// vim: tw=80
